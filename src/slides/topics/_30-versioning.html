<section>
  <section>
    <h3><mark>Versioning</mark> & Compatibility</h3>
    <p>Managing component versions and ensuring compatibility</p>
  </section>
  <section>
    <h4>Semantic Versioning</h4>
    <pre><code class="language-javascript">// Component with version information
class VersionedButton extends HTMLButtonElement {
  static VERSION = '2.1.0';
  
  static BREAKING_CHANGES = {
    '2.0.0': [
      'Renamed `onClick` property to `handleClick`',
      'Removed deprecated `type` attribute',
    ],
  };

  constructor() {
    super();
    
    // Log version info in dev mode
    if (this.hasAttribute('debug')) {
      console.log(`${this.constructor.name} v${this.constructor.VERSION}`);
    }
  }

  static checkCompatibility(requiredVersion) {
    const [major, minor, patch] = this.VERSION.split('.').map(Number);
    const [reqMajor, reqMinor, reqPatch] = requiredVersion.split('.').map(Number);
    
    // Major version must match
    if (major !== reqMajor) {
      console.warn(
        `Version mismatch: Required v${requiredVersion}, got v${this.VERSION}`
      );
      return false;
    }
    
    return true;
  }
}

// Check at runtime
if (!VersionedButton.checkCompatibility('2.0.0')) {
  throw new Error('Incompatible component version');
}</code></pre>
  </section>
  <section>
    <h4>Feature Detection</h4>
    <pre><code class="language-javascript">class FeatureAwareComponent extends HTMLDivElement {
  static FEATURES = {
    // Core features
    core: true,
    
    // Optional features
    animations: typeof Element.prototype.animate === 'function',
    intersectionObserver: 'IntersectionObserver' in window,
    resizeObserver: 'ResizeObserver' in window,
    
    // Check for specific APIs
    customElements: 'customElements' in window,
    customElementsExtends: (() => {
      try {
        customElements.define('test-ext', class extends HTMLButtonElement {}, {
          extends: 'button',
        });
        return true;
      } catch {
        return false;
      }
    })(),
  };

  connectedCallback() {
    // Adapt behavior based on available features
    if (FeatureAwareComponent.FEATURES.animations) {
      this.useNativeAnimations();
    } else {
      this.useFallbackAnimations();
    }
    
    if (FeatureAwareComponent.FEATURES.intersectionObserver) {
      this.setupLazyLoading();
    } else {
      this.loadImmediately();
    }
  }

  static isSupported() {
    return this.FEATURES.customElements && this.FEATURES.customElementsExtends;
  }
}

// Check before using
if (!FeatureAwareComponent.isSupported()) {
  console.error('customElements not fully supported');
  // Load polyfill or show fallback
}</code></pre>
  </section>
  <section>
    <h4>Polyfill Strategy</h4>
    <pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;script&gt;
  // Check for customElements support
  if (!('customElements' in window)) {
    // Load polyfill
    const script = document.createElement('script');
    script.src = 'https://unpkg.com/@ungap/custom-elements';
    document.head.appendChild(script);
    
    script.onload = () => {
      console.log('customElements polyfill loaded');
      loadComponents();
    };
  } else {
    loadComponents();
  }
  
  function loadComponents() {
    import('./components/index.js');
  }
&lt;/script&gt;</code></pre>
    <pre><code class="language-javascript">// Conditional polyfill loading
async function ensureSupport() {
  const checks = {
    customElements: 'customElements' in window,
    extends: await checkExtendsSupport(),
  };
  
  if (!checks.customElements || !checks.extends) {
    await import('@ungap/custom-elements');
  }
}

async function checkExtendsSupport() {
  try {
    const test = document.createElement('button', { is: 'test-element' });
    return test.getAttribute('is') === 'test-element';
  } catch {
    return false;
  }
}

// Use before defining components
await ensureSupport();
import('./components/index.js');</code></pre>
  </section>
  <section>
    <h4>Backward Compatibility</h4>
    <pre><code class="language-javascript">class BackwardCompatibleComponent extends HTMLDivElement {
  constructor() {
    super();
    this.migrateOldAttributes();
  }

  static get observedAttributes() {
    return [
      'data-value',  // New
      'value',       // Old (deprecated)
      'variant',     // New
      'type',        // Old (deprecated, was renamed to variant)
    ];
  }

  migrateOldAttributes() {
    // Support old attribute names
    if (this.hasAttribute('value') && !this.hasAttribute('data-value')) {
      console.warn('`value` attribute is deprecated, use `data-value`');
      this.setAttribute('data-value', this.getAttribute('value'));
    }
    
    if (this.hasAttribute('type') && !this.hasAttribute('variant')) {
      console.warn('`type` attribute is deprecated, use `variant`');
      this.setAttribute('variant', this.getAttribute('type'));
    }
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // Handle both old and new attributes
    switch (name) {
      case 'value':
        console.warn('`value` attribute is deprecated');
        if (!this.hasAttribute('data-value')) {
          this.setAttribute('data-value', newValue);
        }
        break;
        
      case 'data-value':
        this.updateValue(newValue);
        break;
        
      case 'type':
        console.warn('`type` attribute is deprecated');
        if (!this.hasAttribute('variant')) {
          this.setAttribute('variant', newValue);
        }
        break;
        
      case 'variant':
        this.updateVariant(newValue);
        break;
    }
  }
}</code></pre>
  </section>
  <section>
    <h4>Migration Guide</h4>
    <pre><code class="language-javascript">/**
 * Migration Guide: v1.x to v2.x
 * 
 * Breaking Changes:
 * 1. Attribute `type` renamed to `variant`
 *    - Before: &lt;div is="my-component" type="primary"&gt;
 *    - After:  &lt;div is="my-component" variant="primary"&gt;
 * 
 * 2. Method `onClick` renamed to `handleClick`
 *    - Before: component.onClick = () => {...}
 *    - After:  component.handleClick = () => {...}
 * 
 * 3. Event `item-clicked` renamed to `item:click`
 *    - Before: addEventListener('item-clicked', ...)
 *    - After:  addEventListener('item:click', ...)
 * 
 * Deprecations (will be removed in v3.0):
 * - `value` attribute (use `data-value` instead)
 * - `config` property (use `options` instead)
 * 
 * New Features:
 * - Added `theme` attribute for styling
 * - Added `validate()` method
 * - Added `state-changed` event
 */

class MigrationHelper {
  static checkVersion(component, minVersion) {
    const version = component.constructor.VERSION;
    if (!version) {
      console.warn('Component has no version information');
      return false;
    }
    
    return this.compareVersions(version, minVersion) >= 0;
  }

  static compareVersions(v1, v2) {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);
    
    for (let i = 0; i < 3; i++) {
      if (parts1[i] > parts2[i]) return 1;
      if (parts1[i] < parts2[i]) return -1;
    }
    return 0;
  }
}</code></pre>
  </section>
  <section>
    <h4>Compatibility Testing</h4>
    <pre><code class="language-javascript">// Test suite for version compatibility
describe('Version Compatibility', () => {
  it('should maintain backward compatibility', () => {
    const component = document.createElement('div', {
      is: 'my-component'
    });
    
    // Old API should still work with warnings
    component.setAttribute('type', 'primary');
    expect(component.variant).to.equal('primary');
    
    // New API should work
    component.setAttribute('variant', 'secondary');
    expect(component.variant).to.equal('secondary');
  });

  it('should support gradual migration', () => {
    const component = document.createElement('div', {
      is: 'my-component'
    });
    
    // Both old and new APIs coexist
    component.setAttribute('value', 'old');
    component.setAttribute('data-value', 'new');
    
    // New API takes precedence
    expect(component.dataValue).to.equal('new');
  });
});</code></pre>
  </section>
</section>
